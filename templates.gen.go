// Code generated by internal/cmd/gentmpl/gentmpl.go DO NOT EDIT.
package jsonschema2go

import (
	"text/template"
)

var valueTmpl *template.Template

func init() {
	valueTmpl = template.New("")
	valueTmpl = template.Must(valueTmpl.New("enum.tmpl").Parse(`{{/* gotype: github.com/jwilner/jsonschema2go.enumPlanContext */}}
{{ if .Comment -}}
// {{ .Comment }}
{{ end -}}
{{ if .ID -}}
// generated from {{ .ID }}
{{ end -}}
type {{ .Type.Name }} {{ $.QualName .BaseType }}

const (
{{ range .Members -}}
    {{ $.Type.Name }}{{ .Name }} {{ $.Type.Name }}= {{ printf "%#v" .Field }}
{{ end }}
)

func (m {{ .Type.Name }}) Validate() error {
{{ if .Members -}}
    switch m {
{{ range .Members -}}
    case {{ $.Type.Name }}{{ .Name }}:
        return nil
{{ end -}}
    }
{{ end -}}
    return &validationError{
        errType: "unknown_member",
        message: fmt.Sprintf("unknown value provided for {{ $.Type.Name }}: %v", m),
    }
}`))
	valueTmpl = template.Must(valueTmpl.New("slice.tmpl").Parse(`{{/* gotype: github.com/jwilner/jsonschema2go.slicePlanContext */}}
{{ if .Comment -}}
// {{ .Comment }}
{{ end -}}
{{ if .ID -}}
// generated from {{ .ID }}
{{ end -}}
type {{ .Type.Name }} []{{ $.QualName .ItemType }}

func (m {{ .Type.Name }}) MarshalJSON() ([]byte, error) {
    if m == nil {
        return []byte(` + "`" + `[]` + "`" + `), nil
    }
    return json.Marshal([]{{ $.QualName .ItemType }}(m))
}

{{ if .ItemValidateInitialize }}
var (
{{ range .ItemValidators -}}
{{ with $v := .VarExpr (.NameSpace $.Type.Name "Items") -}}
    {{ $v }}
{{ end -}}
{{ end -}}
)
{{ end -}}

func (m {{ $.Type.Name }}) Validate() error {
{{ range .Validators -}}
{{ if eq .Name "uniqueItems" -}}
    seen := make(map[{{$.QualName $.ItemType}}]bool)
    for i, v := range m {
        if seen[v] {
            return &validationError{
                errType: "uniqueItems",
                message: fmt.Sprintf("items must be unique but %v occurs more than once", v),
                path: []interface{}{i},
                jsonPath: []interface{}{i},
            }
        }
        seen[v] = true
    }
{{ else -}}
	if {{ .TestExpr (.NameSpace $.Type.Name) "m" }} {
		return &validationError{
			errType: "{{ .Name }}",
			message: fmt.Sprintf({{ .Sprintf (.NameSpace $.Type.Name) "m" }}),
		}
	}
{{ end -}}
{{ end -}}
{{ with .ItemValidators -}}
    for i := range m {
        {{ range . -}}
        {{ if eq .Name "subschema" -}}
        if err := m[i].Validate(); err != nil {
            if err, ok := err.(valErr); ok {
                return &validationError{
                    errType: err.ErrType(),
                    message: err.Message(),
                    path: append([]interface{}{i}, err.Path()...),
                    jsonPath: append([]interface{}{i}, err.JSONPath()...),
                }
            }
            return err
        }
        {{ else -}}
        if {{ .TestExpr (.NameSpace $.Type.Name "Items") "m[i]" }} {
            return &validationError{
                errType: "{{ .Name }}",
                message: fmt.Sprintf({{ .Sprintf (.NameSpace $.Type.Name "Items") "m[i]" }}),
                path: []interface{}{i},
                jsonPath: []interface{}{i},
            }
        }
        {{ end -}}
        {{ end -}}
    }
{{ end -}}
	return nil
}
`))
	valueTmpl = template.Must(valueTmpl.New("struct.tmpl").Parse(`{{/* gotype: github.com/jwilner/jsonschema2go.structPlanContext */}}
{{ if .Comment -}}
// {{ .Comment }}
{{ end -}}
{{ if .ID -}}
// generated from {{ .ID }}
{{ end -}}
type {{ .Type.Name }} struct {
{{ range .Fields -}}
	{{ .FieldDecl }}
{{ end }}
}

{{ if .ValidateInitialize }}
var (
{{ range $Field := .Fields -}}
{{ range $Field.Validators -}}
	{{ .VarExpr (.NameSpace $.Type.Name $Field.Name) }}
{{ end -}}
{{ end -}}
)
{{ end -}}

func (m *{{ $.Type.Name }}) Validate() error {
{{ range .Fields -}}
{{ if .Required -}}
	if {{ .TestSetExpr false }} {
		return &validationError{
			errType: "required",
			message: "field required",
			path: []interface{}{"{{ .Name }}"},
			jsonPath: []interface{}{"{{ .JSONName }}"},
		}
	}
{{ end -}}
{{ end -}}
{{ range $Field := .Fields -}}
{{ if ne .Type.Name "interface{}" -}}
{{ range $Field.Validators -}}
{{ if eq .Name "subschema" -}}
    if err := m.{{ $Field.FieldRef }}.Validate(); err != nil {
		{{ if not $Field.Embedded -}}
		if err, ok := err.(valErr); ok {
        	return &validationError{
        		errType: err.ErrType(),
        		message: err.Message(),
				path: append([]interface{}{"{{ $Field.Name }}"}, err.Path()...),
				jsonPath: append([]interface{}{"{{ $Field.JSONName }}"}, err.JSONPath()...),
			}
		}
		{{ end -}}
		return err
	}
{{ else -}}
    if {{ if not $Field.Required -}}{{ $Field.TestSetExpr true }} &&{{ end -}}{{ .TestExpr ($Field.NameSpace) ($Field.DerefExpr) }} {
		return &validationError{
    		errType: "{{ .Name }}",
			path: []interface{}{"{{ $Field.Name }}"},
			jsonPath: []interface{}{"{{ $Field.JSONName }}"},
			message: fmt.Sprintf({{ .Sprintf ($Field.NameSpace) ($Field.DerefExpr) }}),
		}
	}
{{ end -}}
{{ end -}}
{{ else -}}
{{ range $Field.Validators -}}
{{ if eq .Name "subschema" -}}
	if v, ok := m.{{ $Field.FieldRef }}.(interface { Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return err
		}
    }
{{ else -}}
	if v, ok := m.{{ $Field.FieldRef }}.({{ .ImpliedType }}); ok {
		if {{ .TestExpr ($Field.NameSpace) "v" }} {
			return &validationError{
				errType: "{{ .Name }}",
				message: fmt.Sprintf({{ .Sprintf ($Field.NameSpace) "v" }}),
			}
		}
	}
{{ end -}}
{{ end -}}
{{ end -}}
{{ end -}}
	return nil
}

{{ range $t := .Traits -}}
{{ if eq .Template "boxed" }}
func (m *{{ $.Type.Name }}) MarshalJSON() ([]byte, error) {
    inner := struct {
{{ range $.Fields -}}
{{ .InnerFieldDecl }}
{{ end -}}
	} {
{{ range $.Fields -}}
{{ with .InnerFieldLiteral -}}
{{ . }}
{{ end -}}
{{ end -}}
	}
{{ range $.Fields -}}
{{ with .InnerFieldAssignment -}}
{{ . }}
{{ end -}}
{{ end -}}
	return json.Marshal(inner)
}

{{ else if eq .Template "discriminator" }}
func (m *{{ $.Type.Name }}) UnmarshalJSON(data []byte) error {
	var discrim struct {
    {{ with .StructField -}}
        {{ .Name }} {{ if .Type.Pointer -}}*{{ end -}}{{ $.QualName .Type }} {{ if .Tag }}` + "`" + `{{ .Tag }}` + "`" + `{{ end }}
	{{ end }}
	}
	if err := json.Unmarshal(data, &discrim); err != nil {
		return err
	}
	switch discrim.{{ $t.StructField.Name }} {
	{{ range .Cases -}}
	case "{{ .Value }}":
		m.{{ $t.StructField.Name }} = new({{ $.QualName .TypeInfo }})
	{{ end -}}
    {{ with .Default -}}
	default:
        m.{{ $t.StructField.Name }} = new({{ $.QualName .TypeInfo }})
	{{ else -}}
	default:
		return fmt.Errorf("unknown discriminator: %v", discrim.{{ $t.StructField.Name }})
	{{ end -}}
	}
	return json.Unmarshal(data, m.{{ .StructField.Name }})
}

func (m *{{ $.Type.Name }}) MarshalJSON() ([]byte, error) {
	return json.Marshal(m.{{ .StructField.Name }})
}
{{ else if eq .Template "oneOf" }}
func (m *{{ $.Type.Name }}) UnmarshalJSON(data []byte) error {
	tok, err := json.NewDecoder(bytes.NewReader(data)).Token()
	if err != nil {
		return err
	}
	switch {{ if or .Array.Name .Object.Name -}}t :={{ end -}} tok.(type) {
{{- /*gotype: github.com/jwilner/jsonschema2go.marshalOneOfTrait */ -}}
{{ if or .Array.Name .Object.Name -}}
	case json.Delim:
{{ if .Object.Name -}}
		if t == '{' {
			var obj {{ $.QualName .Object }}
			if err := json.Unmarshal(data, &obj); err != nil {
				return err
			}
			m.Value = obj
			return nil
		}
{{ end -}}
{{ if .Array.Name -}}
		if t == '[' {
			var arr {{ $.QualName .Array }}
			if err := json.Unmarshal(data, &arr); err != nil {
				return err
			}
			m.Value = arr
			return nil
		}
{{ end -}}
{{ end -}}
{{ range .Primitives -}}
{{ if eq . "string" -}}
	case string:
		var s string
		if err := json.Unmarshal(data, &s); err != nil {
			return err
		}
		m.Value = s
    	return nil
{{ else if eq . "int64" -}}
	case float64:
		var i int64
		if err := json.Unmarshal(data, &i); err != nil {
			return err
		}
		m.Value = i
		return nil
{{ else if eq . "float64" -}}
	case float64:
		var f float64
		if err := json.Unmarshal(data, &f); err != nil {
			return err
		}
		m.Value = f
		return nil
{{ else if eq . "bool" -}}
	case bool:
		var b bool
		if err := json.Unmarshal(data, &b); err != nil {
        	return err
		}
		m.Value = b
    	return nil
{{ end -}}
{{ end -}}
    }
{{ if .Nil -}}
	if tok == nil {
		return nil
	}
{{ end -}}
	return fmt.Errorf("unsupported type: %T", tok)
}

func (m *{{ $.Type.Name }}) MarshalJSON() ([]byte, error) {
	return json.Marshal(m.Value)
}
{{ end -}}
{{ end -}}

`))
	valueTmpl = template.Must(valueTmpl.New("tuple.tmpl").Parse(`{{/* gotype: github.com/jwilner/jsonschema2go.tuplePlanContext */}}
{{ if .Comment -}}
// {{ .Comment }}
{{ end -}}
{{ if .ID -}}
// generated from {{ .ID }}
{{ end -}}
type {{ .Type.Name }} [{{ .ArrayLength }}]interface{}

{{ if .ValidateInitialize }}
    var (
{{ range $idx, $item := .Items -}}
{{ range $item.Validators -}}
        {{ .VarExpr (.NameSpace $.Type.Name $idx) }}
{{ end -}}
{{ end -}}
    )
{{ end -}}

func (t *{{ .Type.Name }}) Validate() error {
{{ range $idx, $Item := .Items -}}
{{ range $Item.Validators -}}
{{ if eq .Name "subschema" -}}
        if v, ok := m[{{ $idx }}].(interface { Validate() error }); ok {
            if err := v.Validate(); err != nil {
                return err
            }
        }
{{ else -}}
        if v, ok := m[{{ $idx }}].({{ .ImpliedType }}); !ok {
            return &validationError{
                errType: "type",
                path: []interface{}{ {{ $idx }} },
                jsonPath: []interface{}{ {{ $idx }} },
                message: fmt.Sprintf("must be {{ .ImpliedType }} but got %T", m[{{ $idx }}]),
            }
        } else if {{ .TestExpr ($Item.NameSpace) "v" }} {
            return &validationError{
                errType: "{{ .Name }}",
                path: []interface{}{ {{ $idx }} },
                jsonPath: []interface{}{ {{ $idx }} },
                message: fmt.Sprintf({{ .Sprintf ($Item.NameSpace) "v" }}),
            }
        }
{{ end -}}
{{ end -}}
{{ end -}}
    return nil
}

func (t *{{ .Type.Name }}) UnmarshalJSON(data []byte) error {
    var msgs []json.RawMessage
    if err := json.Unmarshal(data, &msgs); err != nil {
        return err
    }
{{ range $idx, $_ := .Items -}}
    if len(msgs) > {{ $idx }} {
        var item {{ $.QualName .Type }}
        if err := json.Unmarshal(msgs[{{ $idx }}], &item); err != nil {
            return err
        }
        t[{{ $idx }}] = item
    }
{{ end -}}
    return nil
}
`))
	valueTmpl = template.Must(valueTmpl.New("values.tmpl").Parse(`{{/* gotype: github.com/jwilner/jsonschema2go.Plans */}}
// Code generated by jsonschema2go. DO NOT EDIT.
package {{ .Imports.CurPackage }}

{{ with .Imports.List -}}
import (
{{ range . -}}
    {{ if .Alias -}}{{ .Alias }} {{ end -}}"{{ .GoPath }}"
{{ end -}}
)
{{ end -}}

{{ range .Structs -}}
{{ template "struct.tmpl" . }}
{{ end -}}

{{ range .Slices -}}
{{ template "slice.tmpl" . }}
{{ end -}}

{{ range .Tuples -}}
{{ template "tuple.tmpl" . }}
{{ end -}}

{{ range .Enums }}
{{ template "enum.tmpl" . }}
{{ end -}}

type valErr interface {
    ErrType() string
    JSONPath() []interface{}
    Path() []interface{}
    Message() string
}

type validationError struct {
    errType, message string
    jsonPath, path []interface{}
}

func (e *validationError) ErrType() string {
    return e.errType
}

func (e *validationError) JSONPath() []interface{} {
    return e.jsonPath
}

func (e *validationError) Path() []interface{} {
    return e.path
}

func (e *validationError) Message() string {
    return e.message
}

func (e *validationError) Error() string {
    return fmt.Sprintf("%v: %v", e.path, e.message)
}

var _ valErr = new(validationError)`))
}
